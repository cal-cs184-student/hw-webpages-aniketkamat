<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Aniket Kamat</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-aniketkamat/hw1/">https://cal-cs184-student.github.io/hw-webpages-aniketkamat/hw1/</a>
		
		<br>

		Link to GitHub repository:<a href="https://github.com/cal-cs184-student/hw1-rasterizer-teama">https://github.com/cal-cs184-student/hw1-rasterizer-teama/sp25</a>
			
		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this assignment, I implemented a rasterizer that can help display SVG files. It uses tools like antialiasing and pixel/level sampling to make the 2D image on the computer screen look more realistic and appear to have gradient/texture features. It helped me learn how to use simpler techniques such as triangle rendering and matrix multiplication to solve complex display problems.
		One interesting thing I learned was that the supersampling method is unexpectedly good for how simple it is to implement compared to many other methods. When I was doing the extra credit for Task 2, I experimented with a few different filtering techniques and saw that most others either produced worse artifacts or more uneven coloring.
			
		<h2>Task 1: Drawing Single-Color Triangles</h2>
		There are two main mathematical ideas behind displaying a triangle. The first is that a line is uniquely defined by the zeros of its function   <li>\[ -(x-X_i)*(X_i+1-X_i) + (y-Y_i)*(Y_i+1-Y_i) \]</li> and that this same function can split the plane into two parts (half-planes), where one contains the (x,y) points for when this function is greater than 0 and one half-plane for when this function is less than 0. 
		The second idea is that since a triangle is defined by three sides (lines), we can define the inside of the triangle as the area where three of the half-planes from the three lines overlap. To check if a point is 'in' a triangle, we can check if it is in each half-plane. So, we can iterate over all the potential points that are in the triangle and check each of them, filling in the corresponding pixel if they are. 
		The algorithm is to use the minimum and maximum values of the given vertex coordinates (min X, min Y, max X, max Y) to define a box and scan over all points in this box. For each pixel, we compute the equation above for each pair of given vertices (defining the center coordinates of the pixel as (x,y), one vertex as (X_i, Y_i) and the other vertex as (X_i+1, Y_i+1)), and check if they are all greater than or equal to 0. Since the given ordering of the vertices may be clockwise or counterclockwise, we test that the line equations are either all >= 0 or all <= 0 to account for orientation.
		My final algorithm is simple bounding box triangle rasterization with further optimizations described below, so it is not worse than simple bounding box triangle rasterization. 
		<br>
		<b>Extra Credit</b>
			
		<table>
		  <thead>
		    <tr>
		      <th>Improvements</th>
		      <th>Approximate Average Triangle Generation Time (ms)</th>
		    </tr>
		  </thead>
		  <tbody>
		    <tr>
		      <td>Basic</td>
		      <td>5.40e-03</td>
		    </tr>
		    <tr>
		      <td>Combining Loops and Limiting Lookups</td>
		      <td>3.71e-03</td>
			</tr>
		    <tr>
		      <td>Implementing Parallelism</td>
		      <td>2.37e-03</td>
		    </tr>
		  </tbody>
			
		</table>
		<br>
		The clock times measured with  <code>clock()</code>  had high variance, so the values were averaged over 3 sets of ~10,000 triangles (by running test3 a few times). The optimizations involved implementing parallelism with OpenMP, limiting memory lookups by computing the line equation only once, and looping over the points only once for both orientations. Interestingly, while implementing parallelism with  <code>#pragma omp parallel for</code>  reduced the run time, collapsing the loops with <code>#pragma omp parallel for collapse(2)</code> performed worse than the purely serial version.
		<figure>
		<img src="test4.png" alt="Test 4" style="width:50%"/>
		<figcaption>Single-Color Triangle Rasterization</figcaption>
		</figure>
		The 'strict' nature of the identity function (because the center of a point is either in or out) can lead to some unusual behavior in edge cases as seen in the pixel inspector above. The red triangle is very thin, so there are some errors (noncontinuity) in displaying it as the centers of the pixels in between technically do not fall inside the triangle. 	
		<h2>Task 2: Antialiasing by Supersampling</h2>
		To implement supersampling, I started with the same algorithm I had used in Task 1 to iterate over the bounding box of the triangle. However, instead of just checking the center of each pixel, I now added two for loops to iterate over a sample rate number of points in each pixel. This was done by checking sqrt(sample rate) x coordinates and sqrt(sample rate) y coordinates for each pixel and keeping track of how many (x,y) pairs were in the triangle for each pixel. The proportion of pairs that were in the triangle for each pixel determined the shade of the pixel (more in the triangle meant that the pixel would be closer to the given color).
		It is useful since it often helps reduce aliasing/jaggies and produces a smoother image. The biggest modification I made to the pipeline was changing when the pixel itself was colored. In the first task, the pixels were filled right after the centers were checked with <code> fill_pixel(x, y, color) </code>. For supersampling, we instead relied on  <code> resolve_to_framebuffer() </code> by computing the proportion of the points in the pixel that were in the triangle, determining the shade that proportion would correspond to, and then actually filling it. 
		As seen in the three images below, this helped antialias the triangles by allowing for pixels with centers 'near' a triangle's edges to still be colored. When supersampling was not being used (rate of 1), there is a gap between parts of the triangle on the left. As the rate increases to 4 and 16 (two triangles on the right), the triangle looks smoother and has smaller gaps since the pixels with centers not in the triangle but close to it are given lighter shades, creating a more natural, connected look. 
		<table>
		  <tr>
		    <td><figure><img src="rateof1.png" width="360" height="270" alt="Rate of 1"><figcaption>Supersampled with Rate of 1</figcaption></figure></td>
		    <td><figure><img src="rateof4.png" width="360" height="270" alt="Rate of 4"><figcaption>Supersampled with Rate of 4</figcaption></figure></td>
		    <td><figure><img src="rateof16.png" width="360" height="270" alt="Rate of 16"><figcaption>Supersampled with Rate of 16</figcaption></figure></td>
		  </tr>
		</table>
		<table>
		  <tr>
		    <td><img src="ec1part2.png" width="360" height="270" alt="Rate of 1"></td>
		    <td><img src="ec2part2.png" width="360" height="270" alt="Rate of 4"></td>
		    <td><img src="ec3part2.png" width="360" height="270" alt="Rate of 16"></td>
		  </tr>
		</table>
		<h2>Task 3: Transforms</h2>
		In this task, I implemented transforms by defining the 3x3 matrices associated with translating, rotating, and scaling. Cubeman is shown below performing a jumping jack with its arms and legs rotated. The process of performing a jumping jack has brought immeasurable joy to cubeman's life, resulting in its inner limbs and face turning different colors.
		<figure>
		<img src="my_robot.png" alt="My Robot" style="width:50%"/>
		<figcaption>Multi-Colored Cubeman Performing a Jumping Jack</figcaption>
		</figure>
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates are an alternative method of evaluating points within a triangle. They give each point a weight that represents how much a certain vertex 'contributes' to a point. For a concrete example, consider the image of the multi-colored triangle on the left below. Place your cursor on the red vertex at the bottom and bring it roughly 80% of the way towards the top side of the triangle. 
		From here, first imagine one line connecting your cursor to the blue vertex on the right and a second line connecting your cursor to the green vertex on the left. These two lines as well as the line between the green and blue vertex define a third triangle entirely contained within the multi-colored one. 
		Repeating this process for the other two sets of vertices as well (blue/red and green/red) gives three total triangles that are entirely contained with the larger one and with areas that sum to the area of the larger one. The Barycentric Corrdinate system uses the area of these triangles to assign weights to the vertex not used in the calculation. In the case of the first triangle (calculated with the blue and green vertices), that would mean that the larger the area is, the more weight assigned to the red vertex.
		Now move your cursor halfway towards the red and imagine the same two lines to the blue/green vertex as above. You can see that the area of the triangle has increased as the point got closer to the red vertex which suggests that more of the red 'contributed' to this point. Barycentric coordinates use this ratio of areas ELABORATE TMRW
		<table>
		  <tr>
		    <td><img src="teachwith.png" width="600" height="450" alt="Teach With"></td>
		    <td><img src="test7.png" width="600" height="450" alt="Test 7"></td>
		  </tr>
		</table>
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is a process for creating a texture effect by choosing colors for the pixels in a rasterized triangle from a texture image. Texture mapping aims to use a 2D texture (image) and place (map) it onto a 3D object to create a more detailed and realistic model. In this case, I implemented this by assigning a 2D coordinate (u,v) to each pointt in the texture image. I computed the Barycentric coordinates for each point in the triangle I was attempting to rasterize and with those weights (say a0,b0,c0), computed the (u,v) coordinates using the given (u,v) coordinates for each vertex.
		For a given vertex (called a), I was given the (x_a,y_b) coordinates as well as the corresponding (u_a,v_a) coordinates on the texture, so now that I had the corresponding weight a_0 from the Barycentric process, I computed the (u_p,v_p) coordinates for a point p in the triangle using the following equation (where b, c represent the other two vertices):
		<li>\[(u_p, v_p) = a_0*(u_a, v_a) + b_0*(u_b, v_b) + c_0*(u_c, v_c) \]</li>
		I scaled this up to the texture size and then sampled from that point on the texture to figure out the color for that point. There were two main methods of sampling. The nearest method simply took the color from the nearest texel on the texture while the bilinear method took the average of the four nearest texels (defined as the texels exactly one unit away on either the u or v axis). In general, the nearest method produces sharper images while the bilinear method produces smoother images. The difference is large when looking closely at an image as the nearest method will look blockier while the bilinear method will show a clearer transition between texels. This is especially visible in high frequency images as the bilinear method may produce more blurs and less jaggies compared to the nearest method.
		<table>
		  <tr>
		    <td><img src="nearest1.png" width="300" height="225" alt="Nearest Sampling at 1 Sample Per Pixel"></td>
		    <td><img src="nearest16.png" width="300" height="225" alt="Nearest Sampling at 16 Samples Per Pixel"></td>
		    <td><img src="bilinear1.png" width="300" height="225" alt="Bilinear Sampling at 1 Sample Per Pixel"></td>
			<td><img src="bilinear16.png" width="300" height="225" alt="Bilinear Sampling at 16 Samples Per Pixel"></td>
		  </tr>
		</table>
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		<table>
		  <tr>
		    <td><img src="lfirst.png" width="300" height="225" alt="L_ZERO and P_NEAREST"></td>
		    <td><img src="lsecond.png" width="300" height="225" alt="L_ZERO and P_LINEAR"></td>
		    <td><img src="lthird.png" width="300" height="225" alt="L_NEAREST and P_NEAREST"></td>
			<td><img src="lfourth.png" width="300" height="225" alt="L_NEAREST and P_LINEAR"></td>
		  </tr>
		</table>
		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		</div>
	</body>
</html>
